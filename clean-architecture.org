[[https://www.kadokawa.co.jp/product/301806000678/][Clean Architecture 達人に学ぶソフトウェアの構造と設計]] の読書メモ

* まえがき・序文

アーキテクチャは最初に決定されて変更することができないものというわけではない。プログラムには変化が求められるということを認め、不完全な運用をされる可能性も否定しない。目的地ではなく旅路。

作者は50年以上プログラムを書き続けている Robert C. Martin なぜかアンクルボブと呼ばれてる。cleancoders.com の共同創業者。ソフトウェアコンサルティング・トレーニング・スキル開発。

50年前と比べるとコンピュータは小さく高性能になったけどプログラミングの構成要素（順次・選択・反復）はさほど変化してない。過去から未来に来た人も、未来から過去に行った人も、少し時間があればプログラミングできるようになるはずだ。構成要素をどのように組み立るか、というアーキテクチャは過去でも未来でも同じように使えるはずだ。

正しいソフトウェアは開発や保守のコストを最小限に減らす。「約束の地」はある。（ユダヤのカナンの地？）

* 第1部 イントロダクション

第1章 設計とアーキテクチャ

「設計」と「アーキテクチャ」を区別しない。下位レベルも上位レベルでも、全体の構造を示す時に使うべき。例：ソフトウェアバージョンアップのたびに、人は増えるが、コードの行数はほんの少しずつしか増えてないグラフ。 グラフが示すのは誤ったアーキテクチャは、開発をすすめるほど生産性が低下するということ。うさぎとかめみたいに、あとでアーキテクチャに置き換えるという考えでは危険。クリーンさを犠牲にしても開発速度は速くならない。

第2章 2つの価値のお話

ソフトウェアシステムは「振る舞い」「アーキテクチャ」という2つの価値を提供する。「振る舞い」は要件によって決まる価値。「アーキテクチャ」は変更しやすさ、拡張しやすさという価値。振る舞いが重視されることが多いが、アーキテクチャも同じかそれ以上に重要である。

* 第2部 構成要素から始めよ：プログラミングパラダイム

第3章 パラダイムの概要

- 構造化プログラミング：goto を排除し、直接的に制御に規律を与えたもの。
- オブジェクト指向プログラミング：関数ポインタを排除することで、間接的に制御に規律を与えたもの。
- 関数型プログラミング：不変性によって、代入に規律を与えたもの。

いずれも、すべきでないことを制限しているということに注目しよう。

第4章 構造化プログラミング

パンチカードでプログラミングしていて、プログラマという職業が認められていない時代。この業界の専門家となろうとしていたダイクストラが、goto が不要であり、むしろ有害であると主張した。ダイクストラは10年以上も批判に晒された。ダイクストラは goto が不要なことを数学的に証明しようとしていたがそれは叶わなかった。それでも現実には goto は使われなくなった。goto の排除が、問題の分割を可能にした。分割したコードをモジュールやコンポーネントと呼ぶようになった。万有引力の法則などは数学的に証明することはできないが、科学的に実証されている。数学的に証明されていないことにも広く価値が認められていることの実例といえる。

第5章 オブジェクト指向プログラミング

かつてC言語では、データ構造の操作をプログラミングする時、ヘッダーと実装を分離することでカプセル化を実現していた。
C++が登場してからデータ構造はクラスとして書かれるようになり、ヘッダーにプライベートメンバ変数を列挙しなければならなくなった。
完全なカプセル化からは遠のいている。Java や C# ではヘッダーと実装の分離をやめた。
つまり、オブジェクト指向言語はカプセル化を重視していない。

継承について。
C言語では異なるデータ構造に対して、それぞれを操作する関数の引数を一致させることで、お互いすり替えても動作するプログラムを書くことができた。
ただし、C言語は型が重要なので、すり替えるときにはキャストが必要である。
より進んだオブジェクト指向言語は継承を使って、これと同じことを簡単に実現できる。

ポリモーフィズムについて。
C言語で標準出力や、標準入力を使う関数はポリモーフィズムを実現している。
仕組みとしては関数ポインタさえあれば、ポリモーフィズムは実現できる。
しかし、オブジェクト指向言語でのポリモーフィズムはより安全で扱いやすい。
ポリモーフィズムを実現したプログラムの優れている点は、
接合すべきものがなんであってもインターフェースさえ満たしていれば再利用可能であるということにある。
言い換えると、ポリモーフィズムは、プラグインを実現できるということである。

依存関係の逆転
ポリモーフィズムを利用しないプログラムは、
常に上位のプログラムが下位のプログラムのインターフェースを知っている必要がある。
そのために include や import などというキーワードを使って依存性を示す。
制御の流れがすなわち依存性につながる。

しかしポリモーフィズムを利用するプログラムはこの依存性を逆転できる。
具体的には上位のプログラムがインターフェースを公開する。
すると下位のプログラムは上位のプログラムの任意の関数を呼び出すことができる。
このとき、制御の流れは上位→下位であるにも関わらず依存性は下位→上位となっているのである。

プログラマは依存性のアーキテクチャを自在に変更できるということである。
たとえばUI、ビジネスルール、データベースの三者があるとき、
ビジネスルールが何者にも依存しないアーキテクチャを作る事ができる。
これが実現すればビジネスルールを変更せずにUIを自由に差し替えるということが可能になる。
より発展させれば、ビジネスルールはそれ単体のライブラリとして独立した開発、デプロイが可能になる。

オブジェクト指向の本質は、依存性の向きを自由自在に変化させること。

補足：ポリモーフィズムというのは元は生物学の言葉で、日本語では多態性などという。
多態性とは同じ生物が違う性質を持っていることを指す。例としては人間の血液型の違いがある。
これはコンピューターサイエンスの文脈では、
同じようなインターフェースを持っている関数はすり替え可能であり、
そのすり替えによってコードの再利用が可能であるということを指して言う。
たとえば、コピーという関数は、読み出しと書き出しの2つの関数ペアが揃っていればいかなる対象もコピー可能である。
このように実装されたコピー関数は、ポリモーフィズムを実現しているなどと言う。

第6章 関数型プログラミング
関数型のプログラミング言語では変数は一度決定されると決して変化しない。
変数が変化しないということは、競合やデッドロックといった問題は起こり得ない。
このことが並列処理に適しているかもしれない。
しかし、その代償として他のプログラミング言語よりも多くリソースを消費することになるだろう。

可変性の分離
一般的な方法として、可変コンポーネントと、不変コンポーネントにわけるという方法がある。
これらを並列処理する場合、競合を避けるためにトランザクショナルメモリを使用するのが一般的。

イベントソーシング
銀行口座の取引を実現するプログラムは素直に考えてみよう。
現在の預金額を記録して、競合が発生しないようにロックを取りながら預金額を変更する。
さて、このような方法とは別に、口座に対するすべての取引履歴のみを記録し、現在の預金額は記録しないという方法がある。
現在の預金額を知るには、わざわざすべての取引を集計しなければならない。
しかし、現在の計算機資源があれば、このような実装でもさほど大きな問題は発生しない。
これが、イベントソーシングという考え方である。イベントソーシングをしながら効率よく計算するには、
たとえば、今日の0時の時点で集計して預金額を記録する。
そうすれば、0時の預金額と0時以降の取引を足し合わせるだけで現在の預金額が計算できる。
このような方針で作られたアプリケーションはCRUDのCRのみを実装すればよく、
すべての値は不変であるため完全な関数型プログラミングが可能である。

まとめ
時代とともに3つのプログラミングパラダイムが生まれた。
いずれも実現できるものを拡張することはなく、
機能を制限することで良い性質を与え、扱いやすくするものであった。

* 第三部 設計の原則
SOLID原則はクラスに対して適用するルール。モジュールレベルの開発に用いる。

- 変更に強い
- 理解しやすい
- 再利用しやすい

40年以上前から洗練されてきた原則なので価値あるものとなっているはずだ。

- 単一責任の原則(single responsibility principle)
- オープン・クローズドの原則(open-closed principle)
- リスコフの置換原則(liskov substitution principle)
- インターフェース分離の原則(interface segregation principle)
- 依存関係逆転の原則(dependency inversion principle)


第7章 単一責任の原則
「モジュールはただ一つのアクターに対して責務を負うべき」という主張。
アクターというのはある指向を持ったユーザーやステークホルダーをひとまとめにしたもの。

単一責任の原則を満たしていない例：想定外の重複
給与システムにおける従業員クラス Employee を考えよう。
このクラスが3つのメソッド calculatePay, reportHours, save を持っている。
実は、それぞれのメソッドを利用する部署が違っている。
言い換えると、このクラスは3つのアクターに対して責任を持っており、単一責任の原則に反する。
たまたま3つのメソッドで同じアルゴリズムで労働時間を計算していたために、
このクラスに実装が集められたのだが、これによって1つのアクターが望んだ変更が他2つのアクターにも影響を及ぼしてしまう。
また、それぞれのアクターのために異なる変更が加えられた時、コンフリクトが発生する。コンフリクト解消の手間は明らかだろう。

解決策
Employee クラスは単にデータ構造（に責任を負う）だけのクラスに置き換える。
そして、3つのアクターのための操作はそれぞれ別のクラスに分割する。
このことが扱いにくく感じるなら Employee のための facade を用意してもよい。

別の案としては、Employee に最も重要なアクターに対する操作だけを残し、
他の機能は他のアクターのためのクラスに委譲する。
（これのほうがオブジェクト指向言語では、自然な気がする）

補足：責任という言葉は responsibility の訳であり、そこには応答可能性というニュアンスが含まれている。
つまり、単一責任の原則とは、クラスや関数はだたひとつの要求や要件に対して応答する機能を持つべきだということを指している。
言い換えると、複数の要求や要件を満たすような機能を持っているクラスはわかりにくく、壊れやすいということである。

第8章 オープン・クローズドの原則
「ソフトウェアは既存の成果物を変更しないように拡張できるようにするべき」という主張。
