[[https://www.ohmsha.co.jp/book/9784274226298/][達人プログラマー 熟達に向けたあなたの旅 （第2版）]] のメモ

* 序文

pragmatic はラテン語 pragmaticus に由来する。これは「実務上の熟達した」という意味。
それ自体はギリシャ語の「行うに適していること」を表す単語に由来する。

第1版が出てから20年が経過したので、古い技術と思想を書き換えて第2版にアップデートした。

大規模なプロジェクトでも、個人の技術とか情熱とかも大事。
自分の能力を少しずつ改善し進歩していくことが大事。

* 第1章 達人の哲学 A Pragmatic Philosophy

*あなたの人生*
「給料が低い」「テクノロジーが古い」「仕事が退屈」とか不満を抱いているプログラマーは多い。でも、それを変化させるための努力は誰もができるはず。バスの中で勉強したり、条件の合う会社を探したり・・・ここはそれができる業界なので頑張って志を持とう。

*猫がソースコードを食べちゃった*
達人は、プロとして責任を取る。失敗があれば、誤りや無知は認める。いい加減な言い訳をせず可能な限り対処して対策を用意する。そうしてチームメンバーの信頼関係が作られる。信頼関係がなければ良い仕事はできない。筋の通った主張になっているか自分の心と対話しよう。

*ソフトウェアのエントロピー*
ソフトウェア開発も時間と共に無秩序になる。割れた窓（悪い設計、誤った意思決定、質の低いコード）は修復するべき。さもないとエントロピーが増大してソフトウェアは破綻する。

*石のスープとゆでガエル*
チームメンバーが協力してプロジェクトに貢献すれば良いものができるが、今忙しいからとリソースを出し渋ることも多い。そうならないためには、理にかなった要求をすること。そして、未来を想像できるような良いものをアウトプットすること。そうすると、渋っていた人も興味を持って、参加したくなる。逆の立場なら、興味に引き摺られて大きな構想を忘れてしまうことがないように注意。

*十分に良い(good-enough)ソフトウェア*
必ずバグはある。しかしユーザやプログラマー自身を満足させることはできる。そこには技術的な改善とユーザ要求のトレードオフがある。途中で手を止めることも必要。完璧なコードは存在しない。

*あなたの知識のポートフォリオ*
プログラミングの知識は新しい技術、言語、環境の登場により陳腐化していく。プログラマーが持っている知識をポートフォリオとして管理していくと良い。これは金融ポートフォリオの考え方と似ている。定期的に、分散させて、ハイリスクとローリスクバランス良く投資していくべき。また、利益を最大にするために安く買い、高く売ることに注意し、時にはコストの配分を見直しするべき。より具体的な提案は下記の通り。

- 年に1つの言語を学習する
- 月に1冊は技術書を読む
- 技術書以外の本を読む
- 勉強会や講習をうける
- ユーザーグループに参加する
- 環境を変えてみる（OS やエディタを変えてみる）
- 最先端のニュースや記事に目を通す

一つ注意点として、取り入れた情報を批判的にみるということを忘れないように。メディアには偏見や間違った知識が溢れているので。

*伝達しよう！*
プログラマーは会議をしたり、聞き取りをしたり、討論をしたり、ドキュメントを書いたり、意思を伝えることに日々時間を割いている。母国語で意思を伝える時、そこにプログラミングの技術を適用する（例えば DRY, ETC などを当てはめてみる）のは、プログラミングの能力を鍛えるユニークな方法と言える。いくつかのアイデアを列挙する。

- 聞き手のことを知る（ニーズ、興味、能力を把握する）
- 言いたいことを知る（自分が伝えたいことを整理してから文章にする）
- タイミングを選ぶ（聞き手が聞きたいと感じるタイミングで話しかける）
- スタイルを選ぶ（聞き手が事実のみを知りたいタイプか、それとも詳細を知りたいタイプかに合わせる）
p- 見栄えを良くする（デザインテンプレートや、スペルチェック機能などを使おう）
- 聞き手を巻き込む（ドキュメントの草稿をみてもらってフィードバックを受けよう）
- 聞き手になる（質問したり対話しよう）
- 相手の立場になる（メール等は必ず返事をしよう）
- ドキュメントとコードをまとめる（コードの中にトレードオフや意思決定などを書き込もう）

* 第2章 達人のアプローチ A Pragmatic Approach

*良い設計の本質*
「良い設計は、悪い設計よりも変更しやすい」ということを意味する ETC原則 (Easier To Change) が大原則。ETC 原則は、意思決定を助けてくれる。バグ修正、機能追加などで自分がプログラムを書いた時「これによって、システムが変更しやすくなっただろうか？」と自問すると良い。「変更しやすい」という言葉は、どのような変更が行われるか想像できるという前提のもとに立っている。もし、全く想像ができない場合には「書いたコードを簡単に交換できるようにする」という方針をとると良い。git のコミットや pull request を作るときに ETC? みたいなメッセージを出すのも良いだろう。

*DRY 原則 - 二重化の過ち*
コードは変化することを迫られる。ビジネスロジックの変更、チューニングによるアルゴリズムの差し替えなど。プログラマーは、リリースされる前であっても、知識を再編成し、コードにフィードバックする。変更が多いからこそ、知識を二重化してしまった時、手間が増えやすい。もしも片方の知識だけ更新して、もう一方がそのままになっていると矛盾を生じる。これを避けるための原則が DRY原則 (Don't Repeat Yourself) である。これは、同じ知識を2箇所以上に記述するなということを主張している。単にソースコードをコピー＆ペーストするなと言っているのではない。知識の二重化を回避することが重要なので、偶然コードが一致した箇所に対して DRY 原則を適用するべきではない。

DRY はコードに限定した話ではない。例えばプログラムコメントにも DRY は適用するべきである。コードに書いてあることをコメントするのは、知識の二重化に他ならない。他の例としては、データ構造にも DRY を適用するべきである。計算によって求めることができる属性をインスタンス変数に入れるのは、知識の二重化である。パフォーマンスチューニングのために、やむなく違反する場合、その影響が局所的になるように注意深く実装しなければならない。アクセサを使えば将来の変更しやすさを維持することができる。

内部 API を提供するプログラムを書いた時、それを利用するチームは、内部 API のインターフェースを知る必要がある。多くの場合はツールを使ってドキュメントを自動生成し、二重化の手間を和らげる。API を利用するためのクライアントはセントラルリポジトリに格納するのが理想。さもないと API を使いたいサービスごとにクライアントを実装することになり、そこでサービスを横断した知識の二重化、三重化が発生するため。それが外部にも公開している API なら [[https://github.com/OAI/OpenAPI-Specification][OpenAPI]] (昔は swagger という名前だったらしい) のようなフォーマットに従って文書化すると良い。

データスキーマとコードの間に存在する二重化も避けることができないが、イントロスペクションと呼ばれる機能を使ってそれらのコード生成の大部分を自動化できる。他のシンプルな手法としては、データスキーマを気にせず、キー/バリュー形式のデータ構造に格納する方式がある。これにはセキュリティ上の問題があるので、必要なデータが必要な形式で保持されていることを検証するデータ駆動型の検証レイヤーを設けるのが良い。

最も取り扱いが難しい二重化は、プロジェクト内のさまざまな開発者の間で発生する二重化。機能がうっかり二重化されて検出されず、のちのメンテナンス時に問題を引き起こした、という事例は多い。開発者間の頻繁なコミュニケーションが効果的。slack チャンネルを活用する。プロジェクトの「司書」を定めておくと良い。仲間のコードを盗み見流のではなく、互いに学び合うのが良い。

*直交性*
平面状の2つの線分について、それらが垂直に交わることを直交していると言う。プログラミングにおいては、2つ以上のものことが、一方を変更しても他方に影響を与えない場合、それらは直交していると言う。例えば、データベースとUIが直交しているプログラムは良いプログラムで変更しやすい。直交していないものの例としては、ヘリコプターの操縦桿がある。これらのハンドルやペダルはお互い直交していないため、ただ高度を下げたいだけだったとしても複雑な操作が必要となる。このように直交していないシステムは本質的に制御や変更が難しくなる。関係のないもの同士の影響を排除することは極めて重要と言える。自己完結したコンポーネント(Yourdon, Constantine が Structured Design で提唱した凝集度の高いコンポーネント)を設計するべき。

直交性を重視したシステムを作ることで多くのメリットがある。変更の影響が減るので開発期間とテスト期間が短縮できる。作り終えたら忘れてしまって良い。コードの再利用も促進できる。直交しているコンポーネントは他の影響を考えずに自由に組み合わせることができるので単純に計算すると M 機能のコンポーネントと N 機能のコンポーネントを組み合わせれば M * N の機能を提供できる。コンポーネントに問題があったとしても、システムの他の部分へ影響しないので切り離し、取り替えができる。特定のベンダーに強く依存することを避けられる。

直交性のあるシステムは、独立したモジュールの組み合わせで作られることが多い。またモジュールには階層を定める。上の階層は、下の階層の機能だけを使ってプログラムを実現するようにすれば、依存関係を整理することができる。設計に直交性があるかどうか確認するには、コンポーネントの要求が大きく変わった時に、どれだけ多くのモジュールに影響が及ぶのかを考える。システムに直交性があるなら、その答えは1つになるはずだ。もちろん、現実的にはそうでないことが多いが。ツールキットやライブラリを導入する時にも、システムの直交性が維持できるかと言うことに注意しなければならない。

- 恥ずかしがりなコードを書く（不必要な情報を公開しない。他のモジュールの実装をあてにしない）
- グローバル変数を使わない
- 類似機能を避ける

と言うことに注意してコードを書いていくと良い。ユニットテストを書くとき、そこで直交性を推し量ることもできる。なぜならテストを動かすためにどのプログラムをインポートする必要があるのか、と言うことがわかるからだ。バグを修正する時にも直交性に対するある種のテストとなる。バグを修正するのにたくさんのコードを書き換えなければならないとしたら、それは直交性を持っていないと言うことだ。そういったものを月次で分析するのも興味深い。

*可逆性*
可逆性のない決定をするのは、なるべく避けたい。例えばデータベースやアーキテクチャを決定して話を進めた場合に起きることを考えよう。そうしてプロジェクトの8割が完成した時に、データベースの性能が問題になったとする。しかしデータベースを固定するという決定をしたために、コードの中にデータベースに依存した実装があり、乗り換えられない。解決策の選択肢が狭まる。
