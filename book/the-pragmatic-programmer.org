[[https://www.ohmsha.co.jp/book/9784274226298/][達人プログラマー 熟達に向けたあなたの旅 （第2版）]] のメモ

* 序文

pragmatic はラテン語 pragmaticus に由来する。これは「実務上の熟達した」という意味。
それ自体はギリシャ語の「行うに適していること」を表す単語に由来する。

第1版が出てから20年が経過したので、古い技術と思想を書き換えて第2版にアップデートした。

大規模なプロジェクトでも、個人の技術とか情熱とかも大事。
自分の能力を少しずつ改善し進歩していくことが大事。

* 第1章 達人の哲学 A Pragmatic Philosophy

*あなたの人生*
「給料が低い」「テクノロジーが古い」「仕事が退屈」とか不満を抱いているプログラマーは多い。でも、それを変化させるための努力は誰もができるはず。バスの中で勉強したり、条件の合う会社を探したり・・・ここはそれができる業界なので頑張って志を持とう。

*猫がソースコードを食べちゃった*
達人は、プロとして責任を取る。失敗があれば、誤りや無知は認める。いい加減な言い訳をせず可能な限り対処して対策を用意する。そうしてチームメンバーの信頼関係が作られる。信頼関係がなければ良い仕事はできない。筋の通った主張になっているか自分の心と対話しよう。

*ソフトウェアのエントロピー*
ソフトウェア開発も時間と共に無秩序になる。割れた窓（悪い設計、誤った意思決定、質の低いコード）は修復するべき。さもないとエントロピーが増大してソフトウェアは破綻する。

*石のスープとゆでガエル*
チームメンバーが協力してプロジェクトに貢献すれば良いものができるが、今忙しいからとリソースを出し渋ることも多い。そうならないためには、理にかなった要求をすること。そして、未来を想像できるような良いものをアウトプットすること。そうすると、渋っていた人も興味を持って、参加したくなる。逆の立場なら、興味に引き摺られて大きな構想を忘れてしまうことがないように注意。

*十分に良い(good-enough)ソフトウェア*
必ずバグはある。しかしユーザやプログラマー自身を満足させることはできる。そこには技術的な改善とユーザ要求のトレードオフがある。途中で手を止めることも必要。完璧なコードは存在しない。

*あなたの知識のポートフォリオ*
プログラミングの知識は新しい技術、言語、環境の登場により陳腐化していく。プログラマーが持っている知識をポートフォリオとして管理していくと良い。これは金融ポートフォリオの考え方と似ている。定期的に、分散させて、ハイリスクとローリスクバランス良く投資していくべき。また、利益を最大にするために安く買い、高く売ることに注意し、時にはコストの配分を見直しするべき。より具体的な提案は下記の通り。

- 年に1つの言語を学習する
- 月に1冊は技術書を読む
- 技術書以外の本を読む
- 勉強会や講習をうける
- ユーザーグループに参加する
- 環境を変えてみる（OS やエディタを変えてみる）
- 最先端のニュースや記事に目を通す

一つ注意点として、取り入れた情報を批判的にみるということを忘れないように。メディアには偏見や間違った知識が溢れているので。

*伝達しよう！*
プログラマーは会議をしたり、聞き取りをしたり、討論をしたり、ドキュメントを書いたり、意思を伝えることに日々時間を割いている。母国語で意思を伝える時、そこにプログラミングの技術を適用する（例えば DRY, ETC などを当てはめてみる）のは、プログラミングの能力を鍛えるユニークな方法と言える。いくつかのアイデアを列挙する。

- 聞き手のことを知る（ニーズ、興味、能力を把握する）
- 言いたいことを知る（自分が伝えたいことを整理してから文章にする）
- タイミングを選ぶ（聞き手が聞きたいと感じるタイミングで話しかける）
- スタイルを選ぶ（聞き手が事実のみを知りたいタイプか、それとも詳細を知りたいタイプかに合わせる）
p- 見栄えを良くする（デザインテンプレートや、スペルチェック機能などを使おう）
- 聞き手を巻き込む（ドキュメントの草稿をみてもらってフィードバックを受けよう）
- 聞き手になる（質問したり対話しよう）
- 相手の立場になる（メール等は必ず返事をしよう）
- ドキュメントとコードをまとめる（コードの中にトレードオフや意思決定などを書き込もう）

* 第2章 達人のアプローチ A Pragmatic Approach

*良い設計の本質*
「良い設計は、悪い設計よりも変更しやすい」ということを意味する ETC原則 (Easier To Change) が大原則。ETC 原則は、意思決定を助けてくれる。バグ修正、機能追加などで自分がプログラムを書いた時「これによって、システムが変更しやすくなっただろうか？」と自問すると良い。「変更しやすい」という言葉は、どのような変更が行われるか想像できるという前提のもとに立っている。もし、全く想像ができない場合には「書いたコードを簡単に交換できるようにする」という方針をとると良い。git のコミットや pull request を作るときに ETC? みたいなメッセージを出すのも良いだろう。

*DRY 原則 - 二重化の過ち*
コードは変化することを迫られる。ビジネスロジックの変更、チューニングによるアルゴリズムの差し替えなど。プログラマーは、リリースされる前であっても、知識を再編成し、コードにフィードバックする。変更が多いからこそ、知識を二重化してしまった時、手間が増えやすい。もしも片方の知識だけ更新して、もう一方がそのままになっていると矛盾を生じる。これを避けるための原則が DRY原則 (Don't Repeat Yourself) である。これは、同じ知識を2箇所以上に記述するなということを主張している。単にソースコードをコピー＆ペーストするなと言っているのではない。知識の二重化を回避することが重要なので、偶然コードが一致した箇所に対して DRY 原則を適用するべきではない。

DRY はコードに限定した話ではない。例えばプログラムコメントにも DRY は適用するべきである。コードに書いてあることをコメントするのは、知識の二重化に他ならない。他の例としては、データ構造にも DRY を適用するべきである。計算によって求めることができる属性をインスタンス変数に入れるのは、知識の二重化である。パフォーマンスチューニングのために、やむなく違反する場合、その影響が局所的になるように注意深く実装しなければならない。アクセサを使えば将来の変更しやすさを維持することができる。

内部 API を提供するプログラムを書いた時、それを利用するチームは、内部 API のインターフェースを知る必要がある。多くの場合はツールを使ってドキュメントを自動生成し、二重化の手間を和らげる。API を利用するためのクライアントはセントラルリポジトリに格納するのが理想。さもないと API を使いたいサービスごとにクライアントを実装することになり、そこでサービスを横断した知識の二重化、三重化が発生するため。それが外部にも公開している API なら [[https://github.com/OAI/OpenAPI-Specification][OpenAPI]] (昔は swagger という名前だったらしい) のようなフォーマットに従って文書化すると良い。

データスキーマとコードの間に存在する二重化も避けることができないが、イントロスペクションと呼ばれる機能を使ってそれらのコード生成の大部分を自動化できる。他のシンプルな手法としては、データスキーマを気にせず、キー/バリュー形式のデータ構造に格納する方式がある。これにはセキュリティ上の問題があるので、必要なデータが必要な形式で保持されていることを検証するデータ駆動型の検証レイヤーを設けるのが良い。

最も取り扱いが難しい二重化は、プロジェクト内のさまざまな開発者の間で発生する二重化。機能がうっかり二重化されて検出されず、のちのメンテナンス時に問題を引き起こした、という事例は多い。開発者間の頻繁なコミュニケーションが効果的。slack チャンネルを活用する。プロジェクトの「司書」を定めておくと良い。仲間のコードを盗み見流のではなく、互いに学び合うのが良い。

*直交性*
平面状の2つの線分について、それらが垂直に交わることを直交していると言う。プログラミングにおいては、2つ以上のものことが、一方を変更しても他方に影響を与えない場合、それらは直交していると言う。例えば、データベースとUIが直交しているプログラムは良いプログラムで変更しやすい。直交していないものの例としては、ヘリコプターの操縦桿がある。これらのハンドルやペダルはお互い直交していないため、ただ高度を下げたいだけだったとしても複雑な操作が必要となる。このように直交していないシステムは本質的に制御や変更が難しくなる。関係のないもの同士の影響を排除することは極めて重要と言える。自己完結したコンポーネント(Yourdon, Constantine が Structured Design で提唱した凝集度の高いコンポーネント)を設計するべき。

直交性を重視したシステムを作ることで多くのメリットがある。変更の影響が減るので開発期間とテスト期間が短縮できる。作り終えたら忘れてしまって良い。コードの再利用も促進できる。直交しているコンポーネントは他の影響を考えずに自由に組み合わせることができるので単純に計算すると M 機能のコンポーネントと N 機能のコンポーネントを組み合わせれば M * N の機能を提供できる。コンポーネントに問題があったとしても、システムの他の部分へ影響しないので切り離し、取り替えができる。特定のベンダーに強く依存することを避けられる。

直交性のあるシステムは、独立したモジュールの組み合わせで作られることが多い。またモジュールには階層を定める。上の階層は、下の階層の機能だけを使ってプログラムを実現するようにすれば、依存関係を整理することができる。設計に直交性があるかどうか確認するには、コンポーネントの要求が大きく変わった時に、どれだけ多くのモジュールに影響が及ぶのかを考える。システムに直交性があるなら、その答えは1つになるはずだ。もちろん、現実的にはそうでないことが多いが。ツールキットやライブラリを導入する時にも、システムの直交性が維持できるかと言うことに注意しなければならない。

- 恥ずかしがりなコードを書く（不必要な情報を公開しない。他のモジュールの実装をあてにしない）
- グローバル変数を使わない
- 類似機能を避ける

と言うことに注意してコードを書いていくと良い。ユニットテストを書くとき、そこで直交性を推し量ることもできる。なぜならテストを動かすためにどのプログラムをインポートする必要があるのか、と言うことがわかるからだ。バグを修正する時にも直交性に対するある種のテストとなる。バグを修正するのにたくさんのコードを書き換えなければならないとしたら、それは直交性を持っていないと言うことだ。そういったものを月次で分析するのも興味深い。

*可逆性*
可逆性のない決定をするのは、なるべく避けたい。例えばデータベースやアーキテクチャを決定して話を進めた場合に起きることを考えよう。そうしてプロジェクトの8割が完成した時に、データベースの性能が問題になったとする。しかしデータベースを固定するという決定をしたために、コードの中にデータベースに依存した実装があり、乗り換えられない。解決策の選択肢が狭まる。

そうならないように本書で紹介する技術を使用していけば後戻りできない意思決定から解放される。たとえば、ウェブアプリケーションをモバイルアプリに置き換えたいという要求が出てきたときであっても、正しく分離がなされていれば本質的にはビューを取り替えるだけで良いはずだ。

アーキテクチャにおけるベストプラクティスはたくさん発生している。いろいろな流行があって、変化が激しい。それに備えて準備しておくことなどできない。できるのは「変更しやすくする」ということだけ。

*曳光弾*
曳光弾(tracer bullets)とは、銃の軌跡が見えるようにした弾丸のこと。着弾した場所を観察して、照準を調整するのに使う。プログラミングにも同じ考え方が適用できる。今までに作ったことがないものを作る時、動き回る目標に対するフィードバックを得るのに使う。ユーザの曖昧な要求や、不慣れなアルゴリズム、開発手法・言語・ライブラリ等、わからないことが多い時にこの考えは役立つ。

曳光弾は使い捨てではない。エラーチェック、構造化、ドキュメンテーション、自動生成したコードなど全て残す。これらは完全に動作するものではないかもしれないが、最終的には肉付けしていって使えるものにする。曳光弾を使った開発では、古典的な開発手法と比べると下記の利点がある。

- 早いうちからユーザーに成果物を提示できる
- 作っているもののビジョンが、開発者に見えやすくなる
- テスト用のプラットフォームができる
- デモンストレーションができる
- 進捗がわかりやすくなる

曳光弾の着弾点は目標点ではない。そのため、何度も発射して狙い直す必要があるということに注意。プロトタイピングと似ているが、プロトタイピングは成果物を一回捨て去って再構築するという点が違う。プロトタイピングの目的は、アプリケーションのある側面を探究するためのものである。一方、曳光弾の目的は、ユーザに早い段階でアプリケーションの振る舞いを提示することと、アーキテクチャの骨格を開発者に提示することの二つである。

プロトタイピングが力を発揮する例として、さまざまな大きさの積荷をコンテナに詰め込む問題がある時、その最適な答えを探すアプリケーションを考えてみよう。このアプリケーションがどのような GUI を持つべきかわからないので、内部的なアルゴリズムは一旦無視して、UI だけのサンプルを作る必要があるだろう。また、コンテナに積荷を詰め込むアルゴリズムについても、考えやすい高級言語を使って試作し、最適なアルゴリズムを見つけ出す必要があるだろう。そうして、GUIとアルゴリズムに対する知見が十分に貯まったときに、本番環境へ向けてコードを作り直す。これはプロトタイピングが適している。

*プロトタイプとポストイット*
自動車メーカーでは、デザインのことなる新車をプロトタイプとして作成している。見た目のテストはもちろん、空気抵抗や構造的特性をテストするためにも使われる。ソフトウェアのプロトタイプも同じようなもので、大きなコストをかけずに、リスクを分析するために作る。プロトタイプは必ずしもプログラミングによって作られる必要はなく、ポストイットを使ったプロトタイプもあり得る。ホワイトボードに絵を描いたり、ペイントプログラムを使っても良い。

プロトタイプによる調査が適しているのは、過去に試されたことのないケースや、実証されてないケースなど、リスクの伴うケース。プロトタイプの核心は得られたコードではなく学び。プロトタイプはさまざまな詳細を無視することができる。すべての機能を実装する必要はなく、データはダミーデータでもよい。また、エラーチェックなどもする必要はない。プロトタイプには高水準で使いやすいスクリプティング言語 Python や Ruby が適している。

アーキテクチャのプロトタイピングではホワイトボードにポストイットを貼り付けるだけでも良い。コンポーネントの責務が適切に分割されていて、協調できるようになっているか、二重化されてないか、などコードを書かなくても検討できることはたくさんある。

プロトタイプは破棄するということは関係者間で共通認識である必要がある。どんなに見栄えがよくても、模型をそのまま製品に使うことはできない。曳光弾によるアプローチなら、コードをそのまま使うことができる。

*専用の言語*
プログラミング言語はそれぞれが特徴を持っていて、それ自体が問題解決の方向性を決めたりする。なので問題領域に DSL があるなら、それを使うと問題解決が進めやすくなることもある。RSpec, Cucumber, Phoenix(のrouter), Ansible など。内部ドメイン言語は RSpec のような言語で、これはホスト言語(ruby) の機能をそのまま利用できるというのがメリット。ただしあくまで ruby の文法に従う必要はある。外部ドメイン言語は Ansible のような言語で、これは何かのホストに依存しないので文法もそれ自体が決定する（実際には完全に独自文法をもっていることはまれで、何かの言語や文法を下敷きにしていることが多い）。

*見積もり*
一番簡単な見積もり方法は、似たような仕事を経験した人に聞いてみること。そうでない場合は問題を把握してモデルを作ること。具体的には、時間 = 何かのパラメータによって決定する数式、のような形を作る。そしてパラメータを与えると見積もりができる。闇雲に推定せずに思考のプロセスを残しておくと、見積もりが外れた時も反省して次の見積もり精度向上につなげることができる。例：100TB のデータは 1Gbps でダウンロードした時、何時間かかるか？

米軍で使われる見積もり手法として Program Evaluation and Review Technique(PERT) というものがある。これは、タスクごとに「楽観的時間」「標準時間」「悲観的時間」の3つを見積もりする。そしてそれらを集計して見積もりを出す。この方法が最善というわけではないが、不確実さを盛り込んだ見積もりとして役に立つかもしれない。

他の見積もり方法としては、ちいさなイテレーションを実際に動いてみて、イテレーションが何周したら良いのか、というのを考える手法もある。

* 第3章 基本的なツール

道具を手に馴染ませる
