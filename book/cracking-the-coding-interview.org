世界で闘うプログラミング力を鍛える本〜コーディング面接189問とその解法〜のメモ。

https://book.mynavi.jp/supportsite/detail/9784839960100.html

2016年の本なので少し古い。どこかでおすすめされてるのを見たので買ってみた。

** VII 技術的な質問

口頭試問の解答フローチャート

1. 問題を読む ... 余分な情報は与えられないことに注意
2. アルゴリズムなしで、1つの例を解く ... 図を使う、例はある程度の複雑さが必要
3. アルゴリズムを作る(総当りで解く)
4. アルゴリズムの計算量を考える
5. アルゴリズムを最適化する
6. アルゴリズムを見直す
7. アルゴリズムをコードに書き出す
8. テスト ... 最初に作った例だけでなく特殊な例も実験してみる

最適化の考え方

- BUD を探す
  - Bottlenecks
  - Unnecessary work
  - Duplicated work
- 自分でやってみる
  - 人が問題を解くと自然と最適化された答えを見つけられることがある
  - 例：二分探索とか知らなくても辞書を引くときはそれと似たことをする
- 単純化と一般化
  - 例：単語を取り扱う問題では、文字を取り扱うように考えてみるとよいかも
- 小さな状態から大きな状態を作る
  - 例：abcdefg の順列を考えてみる
    - case(a) => { a }
    - case(ab) => { ab, ba }
    - case(abc) => c を { ab, ba } の全ての位置に挿入する
                => { cab, acb, abc, cba, bca, bac }
- データ構造を一個ずつ検討する
  - 例：ランダムに数値が生成され、配列に追加されていく。このとき中央値を調べるにはどうするか。
    - 連結リスト ... はアクセスやソートに向いてないので x
    - 配列 ... できそうだがソートのコストは大きい ▲
    - 二分木 ... 効率よくできそうだが正確な中央値を出すのはアルゴリズム的に難しそう ▲
    - ヒープ ... これが一番適しているらしい（詳細はよくわからなかった） ○
- BCR(best concervable runtime) 最良実行時間を手がかりにする
  - 例： 長さ A, B の配列が共通して持っている要素の数を考える
  - 全く同じの場合でも A と B を一個ずつ調べるから計算量 O(A+B) 以上のはず
  - 一方総当りのアルゴリズムでは A と B で二重ループするから計算量 O(A*B) となる
  - アルゴリズムが最適化できるとしたら O(A*B) 〜 O(A+B) の範囲で改善できそうだとわかる

面接のポイント

- 正答することだけが加点要素ではない
- 最適化の度合いや、考えていた時間、コードの品質など
- 短く書ける言語のほうが楽
- 良いコード
  - 正常に動く
  - 効率が良い
  - シンプルである
  - 読みやすい
  - 保守しやすい
- データ構造やクラス設計で「過度な最適化」を恐れる必要はない
  - 自身の設計する力を示すのには問題ない
  - 現実の問題では、過度な最適化かどうかを判断するのにもっと時間を使える

** VIII オファーとその後

- 不採用になってももう一度チャレンジできる事が多い
  - たまたまうまく行かなかったということは普通にある
  - 場合によってはフィードバックがもらえるのでそれを活かそう
- 交渉は怖いが経済的価値がある
  - 自動車の購入で A: $20000 B: $19500 とする。
    ただし A は交渉不要 B は交渉必要としたとき、A を選ぶ人もそれなりにいる。
- オファーを受けた時も交渉していい
  - おそらく採用が取り消されたりはない
- コツ
  - 具体的に依頼する（$7000 上げてほしいとか）
  - 依頼額がそのまま乗ることは少ないので、余分に要求してみる
  - 給与以外の方法でもらう（引越し費用という名目で一時金でもらうとか）

仕事の中でやること

- 展望（キャリア）を考える。進展がないと思ったら辞めてもいい。
- 仕事の中で強い関係性をつくる。私生活でも友人を大切にする。
  - 仕事をやめて新しいことを始めるときにも、紹介してもらうほうがずっと良い。
- 自分のやりたいことをマネージャーにちゃんと伝える
  - 伝えないと何もしてくれない人のほうが多い
  - 自分で動く
- 転職市場を眺め、面接対策はしておく

** IX 問題

*** 1 配列と文字列

おそらく Java 前提になっている

**** Hashtable

1. キーからハッシュ値を計算する(キーは無限だがハッシュ値は有限なことに注意)
2. ハッシュ値から配列のインデックスを計算する
3. 配列のインデックスの指す場所にアクセスし値を保存・参照する(値の衝突に備えて、配列の中身は連結リストにする)

キーの数を N とする。
最悪実行時間はすべてのキーのハッシュ値が衝突してしまう O(N) だが
ハッシュ値が衝突しないように作られていれば O(1) で操作ができる。

ハッシュテーブルを二分木で構成することもできる。
この場合は操作が O(log N) となる。

**** ArrayList

ArrayList は、通常の配列と違って必要に応じて自身のサイズを変化させる。
一般的な実装は、配列がいっぱいになったときに、サイズを2倍にするというもの。
普段の配列の操作は O(1) で高速に動く。サイズを増やすときに O(N) の計算量が発生する。
ただしサイズを増やす機会はかなり少ないのでならして O(1) と考える事が多い。

**** StringBuilder

下記の関数の計算量を考えてみる。

#+begin_src java
String JoinWrods(String[] words) {
  String sentence = "";
  for (String w : words) {
    sentence = sentence + w;
  }
  return sentence;
}
#+end_src

このメソッドでは与えられた strings の個数 n に対して O(n) で計算する。
strings の各要素の長さがすべて x で同じだと仮定すると
ループの1回目に x をコピー、2回目に 2x をコピー ... となり
x + 2x + 3x + 4x + 5x ... + nx ステップの計算が発生する。
これはまとめると O(xn^2) という計算量になり非効率である。

StringBuilder では文字列のコピーが各ループ毎に x となり O(xn) で実行可能である。
