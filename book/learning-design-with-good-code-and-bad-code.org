https://gihyo.jp/book/2022/978-4-297-12783-1
良いコード／悪いコードで学ぶ設計入門

必ずしも評判が良いとは言い切れないが知っておくべき本だとは思ったので読んでみる。

https://zenn.dev/339/articles/e3c174fdcc083e

* 第1章 悪いコード

- 命名が悪い
- 条件分岐が過剰に複雑
- 低凝集
- 重複
- 初期化忘れ（コンストラクタがない）

* 第2章 設計の初歩

- 省略名を使わない
- 変数に再代入しない
- メソッドを使う
- 関連のあるメソッドをまとめる（凝集）

* 第3章 クラス設計

- クラス1個で意味がわかるようにする
- クラスの不正状態が生まれないようにする
- イミュータブルにする

* 第4章 イミュータブル

- ミュータブルオブジェクトは再利用時に全ての再利用箇所に影響がある
- 呼び出すたびに状態が変わっていると振る舞いが予測困難になる
- パフォーマンス目的でない限りイミュータブルである方が良い

* 第5章 凝集性

- なるべく近い機能を一つのクラスに集める＝凝集性を高くする
- 初期化パターンが有限なら factory パターンを使う方法がある
- common とか util とかは凝集性が低い
- ログ出力などの横断的関心事は common にしてもいい
- メソッドチェーンはデメテルの法則に反するので控えた方がいい

* 第6章 条件分岐

- switch をポリモーフィズムで置き換える
- java なら interface が役に立つ
- アルゴリズムに注目するときは strategy パターンと言える
- リスコフの置換原則に従うべき（いかなるサブクラスでも動くようにし、instanceofによる分岐を避ける）

# ruby だとダックタイピングかな。
# 銀行振込に関して、全ての銀行に振り込みメソッドが用意されていた。
# bank_type.classify.send_money のような感じ。
# 銀行ごとにコピーして画面を作っていた。
# 実際には振込方法は3-4種類しかない。
# なので、銀行のポリモーフィズムはやめて単なる分岐にした。
# 振込手法だけをストラテジパターンにすればよかったのだろうと今は思った。

* 第7章 コレクション

- コレクションの each だけでなく find などのいろいろなメソッドを利用しよう。
- first class collection パターンを使ってみよう: ある条件を満たすコレクションのラッパー。
- 上記はイミュータブルにもできる

* 第8章 密結合

- 強い依存があることを密結合という。
- 単一責任の原則に従うのが良い。
- 過剰に共通にしないという選択ができるかどうか・・・。
- 継承は密結合になりやすい。
- 不用意に public にしない方がいい。

* 第9章 その他

- デッドコードは消すべき。
- YAGNI の原則に従うべき。
- マジックナンバーは定数にするべき。
- グローバル変数は減らすべき。
- nullable にしないほうが良い。
- エラー・例外の握りつぶしはやめる。
- メタプログラミングはなるべく避ける。
- パッケージはドメインで分割した方が良い（と筆者は主張しているが実際は必ずしもそうではないだろう）
- サンプルコードをコピペしない方がいい。
- デザインパターンとか学んだ手法を試したくなるけどかえって良くない結果になることもある。

* 第10章 名前の設計

- （ビジネス上の概念・用語マッピングが設計とすると、その設計はビジネス上の目的目線でやるとうまくいくのではないかという筆者は主張している。これは筆者以外に主張している著名人を見たことがないので、そういう仮説だと思った方が良いだろう）
- 責任が大きすぎるクラスを設計してしまったら、影響範囲を分解する（関心事の分離）を考える。
- 関心事が分離できれば大きいクラスは不要になる。（かもしれない）

* 第11章 コメント

省略

* 第12章 メソッド

- レシーバーに対する変更以外は避けた方が良い
- immutable がよい
- メソッドはコマンドかクエリかのいずれかにする（コマンドクエリ分離原則）

* 第13章 モデリング



* こうだったらいいなと思う点

良いコード・悪いコードが見開きになっている。
左と右で比較して、このコードが良い・悪いという議論ができる。
