[[https://www.oreilly.co.jp/books/9784873119823/][ソフトウェアアーキテクチャの基礎]] の読書メモ

個人的なおすすめ章：1,2,3,8,9章

* はじめに：公理を疑う
数学の世界では自明のことを公理と言ってそこから議論をスタートする。
ソフトウェアの世界では自明のことがどんどん変化するので常にアップデートしながら考えていこう。

* 第1章 イントロダクション

アーキテクチャというものは下記の理由により説明し難い。

- 厳密な定義がない
- 複雑でいろいろな概念を含む
- それを巻くエコシステムが進化している
- 過去の適切でない用語が未だに残っている

1.1 アーキテクチャを定義してみよう。

- 構造
- アーキテクチャ特性：システムがサポートする ility （可用性、信頼性、テスト容易性…）
- アーキテクチャ決定：構造に対するルール、アクセスの制限
- 設計指針：ガイドライン

1.2 アーキテクトが期待されることを考えてみよう。

- アーキテクチャを決定する
- アーキテクチャが期待通り健全に機能しているか分析する
- アーキテクチャ検討に耐えるだけの知識がある（広範な知識・トレンド・ドメイン知識）
- 交渉・政治

1.3 アーキテクトと他の役割との関係性を考えてみよう。

- エンジニアリングプラクティスとの関係
  - エンジニアリングプラクティスとは再現性のある手法のこと（例：継続的インテグレーション）
  - アーキテクチャが健全に動いていることを確かめるのに適応度関数(fitness function)という考え方を使うことがある
- Devops との関係
  - かつてはアーキテクトが運用を管理できない前提になっていた。過度に防御的になり不要な複雑さを抱えていた。
  - 今ではアーキテクトが運用を管理におく前提になってきた。複雑さが減った。
- 開発プロセスとの関係
  - かつてはアーキテクチャは設計で、設計通りのものができるなら開発プロセスは関係ないと考えられてきた
  - 今では未知の未知な問題と遭遇したときにアーキテクチャの変更が迫られることも踏まえてイテレーティブな開発がよいと言われてる
  - リアーキテクチャの進め方は特に開発プロセスと関わりが深い
- データベースのアーキテクチャも大事

1.4 ソフトウェアアーキテクチャの法則を考えてみよう。

- 第一法則：ソフトウェアアーキテクチャはトレードオフがすべてだ
- 第二法則：「どうやって」よりも「なぜ」の方がずっと重要だ

* 第1部 基礎
** 第2章 アーキテクチャ思考

以下のものをアーキテクチャ思考と呼ぶ。

- 2.1 アーキテクチャと詳細設計を切り離すべきでない。
      アーキテクトは開発チームとコラボレーションするべき。
      選択したアーキテクチャが期待通り機能しているか知るにはチームに参加するしかない。
      また、チームにアーキテクチャを馴染ませる狙いもある。
- 2.2 アーキテクトは、開発者より幅広い知識を持たなくてはならない。
- 2.3 いかなるアーキテクチャについても完璧なものはなく場面ごとに適切なものを選択する。
      アーキテクチャを使うことで得るもの、失うものを分析するべき。すべてはトレードオフ。
- 2.4 ビジネス要件を理解しアーキテクチャを選択するべき。
- 2.5 アーキテクチャを考えるだけでなくコーディングもするべき。
      ただしアーキテクトがチームのボトルネックになってはいけないので下記の仕事をやるのがおすすめ。
  - 実証実験/概念実証(proof-of-concepts)をやる。
  - 技術的負債やアーキテクチャに関わるタスクを引き受ける。
  - バグ修正タスクを引き受ける。
  - ツール作成、自動化などに取り組む。

** 第3章 モジュール性

モジュール性のよさは、頻繁に語られる。
どんなプログラミング言語でもモジュールを作る機能を備えている。
アーキテクチャがモジュール性を持つことは暗黙的な要求であるが、これは常に重要。
アーキテクトはモジュール性を理解してシステムを設計しなければならない。

- 3.1 モジュールとはコードを論理的にグループ化すること。
- 3.2 モジュール性を示すメトリクスは研究されてきた。
  - 凝集度(cohesion) は、グループに含まれるコードの関連の強さを指す。
    必然的な理由でグループ化している場合、凝集度は高い。
    必然性がないのにグループ化してしまっている場合は、凝集度が低い。
    具体的なメトリクスとして LCOM(lack of cohesion in Methods) がある。
    ただしこれは盲信できるほど強力なメトリクスではない。
  - 結合度(coupling) は、モジュールの呼び出す/呼び出されるという依存関係に注目したメトリクス。
    - あるモジュールが、他のモジュールを呼び出している数を C^e とする。
    - あるモジュールが、他のモジュールから呼び出されている数を C^a とする。
  - 抽象度(abstractness) は、抽象要素の数 / 要素の数である。
    抽象度が高いモジュールは、難解な構造になっている。
  - 不安定度(instability) は C^e / (C^e + C^a) である。
    不安程度が高いモジュールは、多くのモジュールから利用されている。
    そのようなモジュールは、変更された時に壊れやすい。
  - 抽象度を縦軸y、不安定度xを横軸にしてグラフを書く。そして直線 x + y = 1 を主系列とする。
    次に、モジュールをグラフ上にプロットして主系列との距離を調べる。
    この値が小さいモジュールは健全である。そうでないモジュールは目的にそわないものとなっている。
  - コナーセンス(connascence) は結合度を改善したメトリクス。
    あるコンポーネントを変更するとき、別のコンポーネントも変更を要するなら、それらのコンポーネントはコナーセントされていると言う。
    コナーセントされているコンポーネントに必要な変更の種類によってコナーセンスの強さを9段階に定める。
    コナーセンスが強いほどリファクタリングしやすいコンポーネントである。

上記の話はコードの詳細に迫りすぎている。アーキテクトとしてはこれだけを見れば良いと言うものではない。

** 第4章 アーキテクチャ特性

アーキテクチャ特性は、非機能要件とほぼ同じ意味。
可用性、継続性、パフォーマンス、など。
これらの特性は無数にあり、干渉しあうため、すべてをカバーすることはできない。
最善のアーキテクチャを見つけることは不可能なので、どの特性に注目するのかを考えて設計しよう。

** 第5章 アーキテクチャ特性を明らかにする

今作ろうとしているものに対して、どのアーキテクチャ特性を優先するかを決定するには、
ステークホルダーとよく話し合って、要件を分析して決める。
デザイナや他の開発者ともよく相談して決めるべきで、独断で決めるのは危険。

** 第6章 アーキテクチャ特性の計測と統制

アーキテクチャの特性を保つためにはツールを使っていくと良い。
パフォーマンスに関しては First Contentful Paint や First CPU Idle のメトリクスが使える。
内部構造のメトリクスには cyclomatic complectity を使うと良い。
測定のためのツールが各言語に用意されているはず。
java では JDepend や ArchUnit を使うといい。

これらのツールを使ってCIに組み込むことは、適応度関数を定めているということでもある。
アーキテクトは開発者に、その適応度関数の目的をしっかりと伝えておくべき。
Netflix の ChaosMonkey も適応度関数の一種といえる。

** 第7章 アーキテクチャ特性のスコープ

アーキテクチャ特性は、システムレベルのスコープで実現する前提になっている。
これはモノリシックアーキテクチャ以外ほとんど選択肢がなかった時代の名残。

6章で紹介したメトリクスは、コードの評価はできるが、コード外のスコープの評価はできない。
コード外のスコープも評価するため *アーキテクチャ量子* という概念を紹介する。固い定義は下のとおり。

> 高度な機能的凝集と同期的なコナーセンスを持つ、独立してデプロイ可能なアーティファクト

言い換えると、次の性質を持つのがアーキテクチャ量子

- 独立してデプロイ可能
- １つの目的そって機能が集められている
- 同期呼び出しされる機能が集められている

# 非同期に呼び出せる関係性はお互いの実行時間のコストを考えずに利用できる
# 最も結合が弱い、依存が弱いと考えていいのかも

** 第8章 コンポーネントベース思考

- モジュールの物理的表現をコンポーネントという。ruby でいう gem。
- コンポーネントのラッパーをライブラリという。
- コンポーネントはネストすることができる。
- コンポーネントの種類の一つがサービス。

最も大きなレベルでのアーキテクチャの分割はレイヤードアーキテクチャとモジュラーモノリスがある。

- 技術能力による分割 ... レイヤードアーキテクチャ(MVCはそのバリエーション)
- ドメインによる分割 ... モジュラーモノリス

コンウェイの法則によって、組織構造にアーキテクチャ影響を受ける。
逆コンウェイ戦略と呼ばれる方法で、望ましいアーキテクチャを作るために組織構造を変えるという手がある。
一つの機能に注目して開発するとき、モジュラーモノリスのようなドメイン分割のほうが都合が良いようだ。
最近はドメイン分割が選択されることが多い。

アーキテクトが作ったコンポーネント設計はそれで完成ではない。
開発のイテレーションごとにフィードバックを受けて、改良していくべき。

なにもないところからコンポーネントを設計するのは難しい。
手がかりとしては、モデルを見つけるのが最も簡単だが、それ自体はコンポーネントではないので注意。
ただし、シンプルな CRUD アプリケーションを作ろうとしているのならモデルが見つかっていればよく、
複雑なアーキテクチャは必要ない。Rails の scaffold テンプレートのようなものを使えば良い。

- アクター・アクションアプローチ ... ユーザとその操作から検討する昔ながらの手法。
- イベントストーミング ... コンポーネント間の通信やイベントから検討する手法。
- ワークフローアプローチ ... 主要なロールと、ワークフローから

* 第2部 アーキテクチャスタイル
** 第9章 基礎

アーキテクチャスタイルにはいろいろなものがある。

- 巨大な泥団子(big ball of mud) ... アーキテクチャがない
- ユニタリーアーキテクチャ ... ハードウェア組み込みのシステムなど単一のシステム上で動作するアプリケーション
- クライアント・サーバー
  - デスクトップ + データベースサーバー
  - ブラウザ + Web サーバー
  - 3層アプリケーション
    - CORBA ... 異なるプログラミング言語で開発されたシステムでも対話可能なプロトコルを指定したアーキテクチャ
    - DCOM ... 上記のマイクロソフトバージョン。
    - これらのアーキテクチャスタイルは過去のものとなり、アーキテクチャパターンとして部分的に適用される程度になった。

モノリシックアーキテクチャを分散アーキテクチャにすることで得られるもの

- パフォーマンス
- スケーラビリティ
- アベイラビリティ（可用性・継続稼働性）

モノリシックアーキテクチャを分散アーキテクチャにすることで失われるもの

- サービスが通信できない可能性がある（アプリケーションの信頼性が落ちる）
- サービスがお互い通信する分レイテンシーが増える
- サービスの通信では、帯域幅以上の速度は出ない
- サービスが分散することで、攻撃に晒される面積が増える
- サービスを接続するネットワーク機器やその構成が変わってトラブルになることがある
- 関係者が増え、多くのサービス管理者やインフラ担当者とのコミュニケーションが必要になる
- インフラ設備の運用コスト（と費用）は上がる
- ログが分散する
- トランザクションが容易ではなくなる
- サービス間での約束（コントラクト）のバージョン管理が必要になる

** 第10章 レイヤードアーキテクチャ
** 第11章 パイプラインアーキテクチャ
** 第12章 マイクロカーネルアーキテクチャ
** 第13章 サービスベースアーキテクチャ
** 第14章 イベント駆動アーキテクチャ
** 第15章
** 第16章
