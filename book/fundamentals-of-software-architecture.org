[[https://www.oreilly.co.jp/books/9784873119823/][ソフトウェアアーキテクチャの基礎]] の読書メモ

* はじめに：公理を疑う
数学の世界では自明のことを公理と言ってそこから議論をスタートする。
ソフトウェアの世界では自明のことがどんどん変化するので常にアップデートしながら考えていこう。

* 1章 イントロダクション

アーキテクチャというものは下記の理由により説明し難い。

- 厳密な定義がない
- 複雑でいろいろな概念を含む
- それを巻くエコシステムが進化している
- 過去の適切でない用語が未だに残っている

1.1 アーキテクチャを定義してみよう。

- 構造
- アーキテクチャ特性：システムがサポートする ility （可用性、信頼性、テスト容易性…）
- アーキテクチャ決定：構造に対するルール、アクセスの制限
- 設計指針：ガイドライン

1.2 アーキテクトが期待されることを考えてみよう。

- アーキテクチャを決定する
- アーキテクチャが期待通り健全に機能しているか分析する
- アーキテクチャ検討に耐えるだけの知識がある（広範な知識・トレンド・ドメイン知識）
- 交渉・政治

1.3 アーキテクトと他の役割との関係性を考えてみよう。

- エンジニアリングプラクティスとの関係
  - エンジニアリングプラクティスとは再現性のある手法のこと（例：継続的インテグレーション）
  - アーキテクチャが健全に動いていることを確かめるのに適応度関数(fitness function)という考え方を使うことがある
- Devops との関係
  - かつてはアーキテクトが運用を管理できない前提になっていた。過度に防御的になり不要な複雑さを抱えていた。
  - 今ではアーキテクトが運用を管理におく前提になってきた。複雑さが減った。
- 開発プロセスとの関係
  - かつてはアーキテクチャは設計で、設計通りのものができるなら開発プロセスは関係ないと考えられてきた
  - 今では未知の未知な問題と遭遇したときにアーキテクチャの変更が迫られることも踏まえてイテレーティブな開発がよいと言われてる
  - リアーキテクチャの進め方は特に開発プロセスと関わりが深い
- データベースのアーキテクチャも大事

1.4 ソフトウェアアーキテクチャの法則を考えてみよう。

- 第一法則：ソフトウェアアーキテクチャはトレードオフがすべてだ
- 第二法則：「どうやって」よりも「なぜ」の方がずっと重要だ

* 第2章 アーキテクチャ思考

以下のものをアーキテクチャ思考と呼ぶ。

- 2.1 アーキテクチャと詳細設計を切り離すべきでない。
      アーキテクトは開発チームとコラボレーションするべき。
      選択したアーキテクチャが期待通り機能しているか知るにはチームに参加するしかない。
      また、チームにアーキテクチャを馴染ませる狙いもある。
- 2.2 アーキテクトは、開発者より幅広い知識を持たなくてはならない。
- 2.3 いかなるアーキテクチャについても完璧なものはなく場面ごとに適切なものを選択する。
      アーキテクチャを使うことで得るもの、失うものを分析するべき。すべてはトレードオフ。
- 2.4 ビジネス要件を理解しアーキテクチャを選択するべき。
- 2.5 アーキテクチャを考えるだけでなくコーディングもするべき。
      ただしアーキテクトがチームのボトルネックになってはいけないので下記の仕事をやるのがおすすめ。
  - 実証実験/概念実証(proof-of-concepts)をやる。
  - 技術的負債やアーキテクチャに関わるタスクを引き受ける。
  - バグ修正タスクを引き受ける。
  - ツール作成、自動化などに取り組む。

* 第3章 モジュール性

モジュール性のよさは、頻繁に語られる。
どんなプログラミング言語でもモジュールを作る機能を備えている。
アーキテクチャがモジュール性を持つことは暗黙的な要求であるが、これは常に重要。
アーキテクトはモジュール性を理解してシステムを設計しなければならない。

- 3.1 モジュールとはコードを論理的にグループ化すること。
- 3.2 モジュール性を示すメトリクスは研究されてきた。
  - 凝集度(cohesion) は、グループに含まれるコードの関連の強さを指す。
    必然的な理由でグループ化している場合、凝集度は高い。
    必然性がないのにグループ化してしまっている場合は、凝集度が低い。
    具体的なメトリクスとして LCOM(lack of cohesion in Methods) がある。
    ただしこれは盲信できるほど強力なメトリクスではない。
  - 結合度(coupling) は、モジュールの呼び出す/呼び出されるという依存関係に注目したメトリクス。
    - あるモジュールが、他のモジュールを呼び出している数を C^e とする。
    - あるモジュールが、他のモジュールから呼び出されている数を C^a とする。
  - 抽象度(abstractness) は、抽象要素の数 / 要素の数である。
    抽象度が高いモジュールは、難解な構造になっている。
  - 不安定度(instability) は C^e / (C^e + C^a) である。
    不安程度が高いモジュールは、多くのモジュールから利用されている。
    そのようなモジュールは、変更された時に壊れやすい。
  - 抽象度を縦軸y、不安定度xを横軸にしてグラフを書く。そして直線 x + y = 1 を主系列とする。
    次に、モジュールをグラフ上にプロットして主系列との距離を調べる。
    この値が小さいモジュールは健全である。そうでないモジュールは目的にそわないものとなっている。
  - コナーセンス(connascence) は結合度を改善したメトリクス。
    あるコンポーネントを変更するとき、別のコンポーネントも変更を要するなら、それらのコンポーネントはコナーセントされていると言う。
    コナーセントされているコンポーネントに必要な変更の種類によってコナーセンスの強さを9段階に定める。
    コナーセンスが強いほどリファクタリングしやすいコンポーネントである。

上記の話はコードの詳細に迫りすぎている。アーキテクトとしてはこれだけを見れば良いと言うものではない。

* 第4章 アーキテクチャ特性

アーキテクチャ特性は、非機能要件とほぼ同じ意味。
可用性、継続性、パフォーマンス、など。
これらの特性は無数にあり、干渉しあうため、すべてをカバーすることはできない。
最善のアーキテクチャを見つけることは不可能なので、どの特性に注目するのかを考えて設計しよう。

* 第5章 アーキテクチャ特性を明らかにする

今作ろうとしているものに対して、どのアーキテクチャ特性を優先するかを決定するには、
ステークホルダーとよく話し合って、要件を分析して決める。
デザイナや他の開発者ともよく相談して決めるべきで、独断で決めるのは危険。

* 第6章 アーキテクチャ特性の計測と統制

アーキテクチャの特性を保つためにはツールを使っていくと良い。
パフォーマンスに関しては Fisrt Contentful Paint や First CPU Idle のメトリクスが使える。
内部構造のメトリクスには cyclomatic complectity を使うと良い。
測定のためのツールが各言語に用意されているはず。
java では JDepend や ArchUnit を使うといい。

これらのツールを使ってCIに組み込むことは、適応度関数を定めているということでもある。
アーキテクトは開発者に、その適応度関数の目的をしっかりと伝えておくべき。
Netflix の ChaosMonkey も適応度関数の一種といえる。

* 第7章 アーキテクチャ特性のスコープ
