「プログラマー脳」の備忘録。
頭の整理のため各節のタイトルは差し替えている。

* part1 コードを読む
** chapter1 コードが読めない原因

| 知識不足 | コードの言語を知らず文法がわからない           | 長期記憶に問題がある         |
| 情報不足 | コードの全容を知らず何をしているのかわからない | 短期記憶に問題がある         |
| 能力不足 | コードが複雑すぎて脳内シミュレーションできない | ワーキングメモリに問題がある |

** chapter2 コードをより速く読む方法

- 短期記憶を節約するにはチャンキングを行う
- チャンキングとは、コードをかたまりで記憶すること
- チェスの序盤の定石と同じような考え方
- デザインパターンは典型的なチャンク
- チャンクをわかりやすくする「ビーコン」としてマークやコメントを置いてもいい

** chapter3 文法を素早く覚える方法

- 記憶は、エビングハウスの忘却曲線に従う
- 全部を覚える必要はないが覚えていたほうが早いこともある
  - ネットで検索していると余計な情報が目について集中が途切れる
- 文法を覚えるのに最適な方法はフラッシュカードらしい
  - つい検索してしまうこと（＝苦手な概念）をやるといい
  - cerego, anki, quizlet などのアプリがある
  - 不正解の回数をメモすると良い
- 長期記憶しても2日経つと25%しか残らない
- 8週間に26回勉強する習慣をつけたグループは1年後に76%記憶が残った
- 記憶能力
  - 貯蔵強度
  - 検索強度
    - ネット検索ですぐ見つかると強化されない
    - 自分の中から引き出そう・思い出そうとすることで強化される
- 精緻化
  - 脳は情報をフォルダでなくネットワークで貯蔵する
  - 自分の信念や知識で整理されたネットワークをスキーマと呼ぶ
  - 情報はスキーマに沿って覚えやすいように少し変形されて記憶される
  - 精緻化とは、不要な情報を削ったり覚えるべきことに合わせてスキーマと情報を最適化すること
    - 自分が詳しいことと結びつける
    - 似ていることがらと結びつける
    - 図を描いてみる

** chapter4 複雑なコードの読み方

- 文法知識があっても難しいものはある
- 脳の能力（ワーキングメモリ）が、コードのシミュレーションに追いつかない
- ワーキングメモリを多く消費するコードは「認知的負荷が高い」と言う
- 変数をメモしたり、記憶補助することである程度なんとかなる
- 認知的負荷が高い問題の性質
  - 解こうとする課題が本質的に難しいもの
  - 課題をモデル化して表現することで難しくなっているもの
- 認知的リファクタリングで改善
  - ローカルでわかるコードに置き換える（ラムダをやめてみるとか）
  - 補助線を引く
    - コードを印刷する
    - 全ての変数を丸で囲み、定義箇所と利用箇所に視線誘導のための線を引く
    - 別のペンを用意して、同じように関数・クラスも線を引く
    - 行ったり来たりがしやすくなる
    - ペンは使ってないけど、個人的に、似たようなことはしている
  - 状態遷移表を書く

* part2 コードをさらに読む
** chapter5 コードを理解を速くする方法

すべての変数を下記のように分類する方法がある（が細かく覚える必要はなさそうである）

| 役割の名前           | 意味                           |
|----------------------+--------------------------------|
| ステッパー           | イテレーターを持つ変数         |
| フラグ               |                                |
| ウォーカー           | より抽象的なステッパー         |
| 直近の値の保持者     | なにかを取り出した値を持つ変数 |
| 最も重要な値の保持者 | 目的とする計算結果を持つ変数   |
| 収集者 gatherer      | 総和などを持つ変数             |
| コンテナ             |                                |
| フォロワー           |                                |
| オーガナイザ         |                                |
| テンポラリ           |                                |

- 学生がプログラミングを学ぶのにこれを使う研究がなされていて、良い結果が出ているらしい。
- ハンガリアン
  - hoge_str とか、ハンガリアン記法が隆盛だったが後からIDEで型確認が容易になってから不要になった。
  - hoge_col (列インデックス)とか、よりセマンティックな型を表現したアプリケーションハンガリアン記法は今でも有効。
  - (Meta-Programming: A Software Production Method) という論文に書いてあるらしい。
- プログラムの「文章の理解」と「計画の理解」は違う（※設計理解的なことだと思う）
- より深いコード理解のステップ
  1. フォーカルポイント（エントリポイントや、エラー発生行）を見つける
  2. フォーカルポイントの関連コードを読み、知識を拡張する
  3. 概念を理解する
  4. 横断的な概念を理解する
- コードを読む時間が60%
- コードを読む時、自然言語の文章を読む時と同じ部分の脳が活性化する
- 数値計算のスキルはプログラミングとは相関が低いという研究がある
- 文章を読むスキルは7つあるのでこれをプログラミングにも応用できる

| 文章を読むスキル             | プログラミングでの実践                 |
|------------------------------+----------------------------------------|
| 過去の知識との結びつけ       | 5分〜10分で全体像をみる                |
| 文章の理解度の自己確認       | 印刷して理解できない行にマークをつける |
| 重要な文とそうでない文の区別 | 印刷して重要な行にマークをつける       |
| 推論                         | 変数の役割リストを作る                 |
| 作図・可視化                 | 手書きの図、状態遷移図、トレースなど   |
| 自問自答                     | なぜそういうコードになってるか考える   |
| 要約                         | まとめると、ドキュメントになる         |

** chapter6 コードの問題を早く解決する方法

- 技術的な意思決定の機会はたくさんあるし、考えるべきこともたくさんある
- 普通、人は解こうとする問題からモデルを作る
- モデルによって解き方が難しくなる
- 頭の中にあるのはメンタルモデル
  - 不完全・柔軟
  - 変化する
  - 矛盾することもあるが、使い分けれる
- 短期記憶に読もうとしているコードのメンタルモデルを置くとよい
- 長期記憶にはアーキテクチャ、デザインパターンなどのメンタルモデルを置くとよい
- 想定マシン・仮想マシン(notional machine)とは理想化されたコンピューター
- 完全なメンタルモデルは想定マシンと一致するが効率は悪い
  - 一致してなくても考えやすい方が良いかもしれない
  - 例えば、変数は「箱」としてとらえる
  - ただしそうすると、変数は1個の値しか持てないことを見落としやすくなる

** chapter7 バグの認知

転移について

- すでに学んだ知識が、他の知識と似ていて応用できることを転移(transfer)という
  - 詳しく知っているほど、転移しやすくなる
  - 類似しているほど、転移しやすくなる
  - コンテクストが近いほど、転移しやすくなる
  - その他の要素もある
- 転移の種類
  - low road transfer: 無意識にやっていることの転移
  - high road transfer: 意識的にやっていることの転移
  - 正の転移: 良い影響がある転移
  - 負の転移: 悪い影響がある転移
- 転移は簡単ではない
  - チェスの知識はあまり転移しないことが研究によりわかっている
  - プログラミング言語も同様で、新しい言語を学ぶのに転移は期待しないほうがよい

バグについて

- バグの原因は前提の誤り、仕様の誤りなどの誤認識
- 誤認識されているモデルを修正することを概念変化(conceptual change)と呼ぶ
- 誤ったモデルをアンラーニングする必要があるが簡単ではない
- 概念変化したあとであっても、古い記憶は残っており誤りの原因になることがある（＝抑制）
- ユハソルバ(juha sorva)は誤認識のリストアップを試みた、これは参考になるかもしれないが省略する
- 誤認識があるものだというオープンマインドを持ち、人に相談するのも良い選択
- ペアプログラミングをするのは良い選択
* part3 良いコードを書く
** chapter8 良い命名

- ベテランでも命名の選択は個人で変わるという研究データがある
- 良い命名の方法
  - A: プロジェクト内での一貫性をもつ
  - B: プロジェクト内で文法的ルールを与える
    - 例：辞書に載っている単語を使う
    - 例：5単語以上は使わない
- 命名の性質
  - プロジェクト内の古いコードの単語が再利用されることが多い
  - プロジェクト初期に命名は定着し、自然と変化することはない
- 良い命名は認知負荷を下げたりチャンク化を助ける
- 全体ができてないコーディングに良い命名を探すのは困難
- コードレビューの時に命名の改善をやると良い
- 1文字の変数は特に理由がない限り使うべきでない
  - 論拠となる研究はあるが省略
- 命名の雛形を使うのも良い選択
  - 例：x の件数の命名は x_count に統一する
- 異なる開発者が同義語を作ってしまった場合は辞書を作るか置き換えるのがよい
- フェイテルソンが考えたよい命名の方法
  - 1. 取り扱う概念リストを考える
  - 2. 概念リストにそれぞれ単語を当てはめて概念マップをつくる
  - 3. 概念マップを使って命名する
  - （ユビキタス言語かな？）

** chapter9 汚いコード

*** 9.1 コードスメル

マーティン・ファウラーが使い出した言葉。
22種類のリファクタリング例を紹介した。

Refactoring: Improving the Design of Existing Code
https://www.ohmsha.co.jp/book/9784274224546/

（これはリファクタリングの根拠にできるよい教材だと思う）

コードスメルがバグの原因となることを示した研究もある。
神クラスがだめなのは、チャンクが作れないため。

*** 9.2 悪い名前

メソッド名は振る舞いと名前が一致するべき。
名前以上のことをしてはいけないし、それ以下のことしかしないようでも困る。
こういう認知負荷の高さをアンケートで測定する研究がある。
Paas スケールというらしい。この方法は一般的に利用されているらしい。
脳波やその他の生理的現象を測定した研究もあるが似た結果になるらしい。

** chapter10 問題解決

*** 10.1 問題解決とは？

- 問題は、初期状態、最終状態、ルールの3つで構成されている。

*** 10.2 問題解決に対する長期記憶の貢献

- 長期記憶の分類
  - エピソード記憶：いわゆる思い出 → 似た問題を思い出して解決を再現する
  - 意味記憶：意味、概念、事実に関する記憶 → 文法知識などが使われる
  - 潜在記憶：箸の使い方など潜在的に実行できる記憶 → タッチタイピング、直感
- 上記のように長期記憶を使って問題解決している

*** 10.3 問題解決のテクニック1: 潜在レベルにする

- 人には、何も考えずに自動的にできることがある：散歩、計算、入浴など
- 問題解決に使うスキルを、この潜在記憶レベルにしておくと問題解決が早くなる
- 潜在記憶レベルにするにはフラッシュカードで意味記憶を覚えて、その後実践を繰り返して反復練習する
- 問題と向き合って解決方法を考えるよりも、過去の類似問題を思い出すほうがはるかに早い
- プログラミングの世界でいうなら、色々な種類の for ループを素振りをする

*** 10.4 問題解決のテクニック2: 公式や規範例を知る

- 問題の解き方が示されていると、問題解決はものすごく早くなる
- これは数学、音楽、チェス、プログラミングなど様々な分野に当てはまる
- 難しい問題を自力で解いて経験をつけるよりも、解法をみながら学ぶほうが効率的に学べる
- 自力で解く場合は、解くことにワーキングメモリを使い果たして、学習にワーキングメモリを使えない
- GitHub を使うとか、本を読むとかで学んでいける

* part4 コードとチーム開発
** chapter11 プログラミング

*** 11.1 CDN

プログラミングはCDN(cognitive dimensions of notation)という考え方によって5つの活動に分けることができる。

- 検索
- 理解：半分以上の時間は理解に使われる
- 転写：何を書くのかが決まっている時の活動
- 増強：機能追加
- 探索：プロトタイピング

*** 11.2 割り込み作業

- プログラミングの集中には波がある
- 割り込まれると復帰まで25分くらいかかる
- 何やってたんだっけを忘れないためのメモを残したおいたほうがよい
- TODO もやっていいけど、TODO は解消されないことが多いので注意
- 計画をたててサブゴールをメモっておくとさらに復帰しやすい
- 集中しているときに赤いランプが点灯するフローライトという器具がある
- 潜在レベルまで自動化できてないことはマルチタスクはできない
** chapter12 大規模開発
*** 12.1 コードベースの特性

- CDCB による特性分類
  - エラーの発生しやすさ
  - 一貫性
  - 拡散性
  - 隠れた依存関係
  - 暫定性(provisionality)：とりあえず書いてみるができるかどうか
  - 粘性(viscosity)：変更の難しさ
  - 段階的評価(progressive evaluation)：不完全なコードの実行可能性
  - など・・・。
- 特性を改善するための変更を設計上の処置(design maneuver)と呼ぶ。
- 多くの場合、ただ改善することはできず、何かの特性は下がるトレードオフになる

*** 12.2 コードベースの特性とプログラミング活動

略

** chapter13 オンボーディング
*** 13.1 オンボーディングの問題点

- ありがちな失敗
  - 大量のインプットをしてしまう
  - シニアにとって小さなタスクはジュニアにとっては認知負荷が高い

*** 13.2 シニアとジュニアの違い

 ピアジェのモデル

| 段階         | 年齢範囲 | 主な特徴                           |
|--------------+----------+------------------------------------|
| 感覚運動期   | 0-2歳    | 仮説や計画を持てず、感覚で動く。   |
| 前操作期     | 2-7歳    | 仮説や計画を持てるが活用できない。 |
| 具体的操作期 | 7-11歳   | 仮説を持てるが一般論は出せない。   |
| 形式的操作期 | 11歳以上 | 推論ができる。                     |

これはプログラムの学習レベルにも当てはめることができるのではないか。
言語を取り替えると、高いレベルの人も一度低いレベルに落ちることがある。
初心者がものを学ぶときは semantic wave という波形に従うとされている。

1. 概念説明や必要性といった抽象度の高いことを知る
2. 実際に利用したり具体例を考える
3. 再び応用のために抽象的なことを考える

これは長期記憶に知識を格納する上での理想の動き。

*** 13.3 オンボーディングプロセスの改善

- 案1: 活動の種類を減らす。検索だけにする、転写だけにするなど。
- 案2: 記憶のサポートをする
  - 一緒に説明する
  - ドキュメントを見せる
  - ドキュメントを書いてもらう
  - ビジネス領域の学習
  - フラッシュカードを用意する
- 案3: コードを一緒に読む
